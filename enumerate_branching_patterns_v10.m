function result_list = enumerate_branching_patterns_v10( tempfile, num_levels, length_array, angle_array, collapse_array)

% modified to call btsl_draw_tree_different_angles_13 which calculates
% steric clash using measured value for branch diameter instead of
% estimating it as a ratio of branch length as in previous versions

%enumerate_branching_patterns_v10('/Users/wallacemarshall/papers/Wei_branching_simulation/btsl_temp_file.txt', 8, [105 50 95 157 178 173 96 61], [176 180 81 59 65 83 103 125], [0 0 0 1 2 3 4 5])



% Conventions for lenth and angle array:

% length array the first entry is NOT the trunk branch (a.k.a. primary branch which is yellow in Wei's drawings), rahter it is the
% first pairof branches that come out of the main trunk, also called
% "secondary branch".  it is OK that we don't give a length for the primary
% branch because it has no influence on any of the spatial statistics for
% endpointdistribution.

% the SECOND entry is the trifurcating branch, also called "tertiary
% branch" which is colored light blue in the Figure.

% conventions for rule sequences:
%  each entry in the rule vector specifies the branching orientation of the
%  CHILDREN of the corresponding branch.  so the first entry concerns the
%  tertiary branch and tells which way its children (i.e. the fourth branch) will be oriented.
%  the final entry describes the second-to-last branching level and
%  specified which way the terminal branches will be oriented.
%  the orientation of the tertiary branch itselfis always fixed to
%  being perpendicular to the primary branch.  this is because the
%  initial simulations were focused on half kidneys so that the dihedral
%  angle was not defined up through the tertiary branching level.  this is
%  a constraint that coudl be relaxed in the future.

% as an example, if the 4th and 5th branches are orthogonal to their
% grandparents, but then all the ones after that are parallel, as is the
% case in the kidney, then the correct rule string should be 001111






% modified from version 8 to use btsl_draw_tree_different_angles_12 in
% which we have corrected the fact that earlier versions (11c) were
% accumulating rotations generated by angle collapse of earlier branches.
% this needed to be fixed since Wei's new scheme for angle collapse is
% strictly in reference to a single branch, and is therefore really a
% global cue not a local cue inherited from an immediate ancester.  this
% new version (12) has been verified by examining the tree diagrams to
% generate correct direction of angle collapse.   hence any results
% generated using enumerate branching pattersn v8 are invalid.

% modified from version 7 to use btsl_draw_tree_different_angles_11c which
% in the case of an invalid direction change (i.e. a direction change
% vector that is coplanar with the two branches but perpendicular to the
% parent) simply doesnt' change the angles for that pair of branches.
% this is necessary beause for certain collapse arrange and branching
% patterns there will be invalid direciton changes during enumeration

% example call
% enumerate_branching_patterns_v7('/Users/wallacemarshall/papers/Wei_branching_simulation/btsl_temp_file.txt', 8, [105 50 95 157 178 173 96 61], [176 180 81 59 65 83 103 125], [0 0 0 1 2 3 4 5])


% example call to the underlying program just for reference
%btsl_draw_tree_different_angles_11c('/Users/wallacemarshall/papers/Wei_branching_simulation/test_file_wholetree_001111b.txt', [180 180 90 60 60 75 90 120], [0 0 0 1 2 3 4 5], 1)


% modified from version 6 o use btsl_draw_tree_different_angles_11b which
% includes the trunk branch in the tree structure

% modified from verison 5b to use btsl_draw_tree_different_angles_11,
% whichi allows the collapse direction array to refer to any earlier
% generation of branching, i.e. 0 is parent, 1 is grandparent, 2 is
% great-grand-parent, and so on, as a way to represent the actual situation
% in the kidney where it may be the case that angle changes are carried out
% in directions parallel to the initial trunk, such that each new
% generation of branches has to refer to an earlier and earlier generation
% branch.    so now collapse array can have any value up to 8.


% modified from version 5 in that it does not enumerate over all collapse
% angle combinations, but just takes one collapse angle array as an input.
% in this array, 0 means collapse parallel to the parent, and 1 is collapse
% parallel to the grandparent branch.



%  MAJOR MODIFICATION - calles btsl_draw_tree_different_angles_v10 which
%  allows angles to change in either of two directions.   this means that
%  now in addition to enumerating over branching patterns, for each
%  branching pattern we also enumerate over all collapse directions.  for
%  this enumeration, we define 1 means the angles change to make the
%  daughters aligned to the parent, and 2 means the angles change to make
%  the daughters aligned to the grandparent.   

% modified rom verison 3 to use btsl_draw)tree_different_angles_v98 which
% also calculates skewness and entropy of radial distance distribution

% modified from version 2 to use btsl_draw_tree_different_angles_v8 which
% calculates and reports steric clash.

% modified from L-system_enumerate to use variable lengths and variable
% angles.   

% example  enumerate_branching_patterns_v2('/Users/wallacemarshall/papers/Wei_branching_simulation/btsl_temp_file.txt', 8, [100 50 200 200 200 200 100 60], [180 180 90 60 60 75 90 120])


% length array based on wei and smythe data
% [100 50 200 200 200 200 100 60]
% note that this has eight values whereas the rule arrays that are
% enumerated only have six because the first two branches never change and
% so they are not enumerated over.

% angle array based on Wei and Smythe data
%[180 180 90 60 60 75 90 120]
% note this also has eight entries for the eight different angles
% the first angle is the first branch off the main trunk, and the second is
% the trifurcation.


% modified from L-system_enumerate to use a convex hull to measure distance
% of each end-point to the surface, where in this case the surface will be
% defined as the convex hull containing all the endpoints

% enumerate all outcomes for all possible rule lists of a given length
% have to give the lengths of the first two branches which don't count in
% the rule list, and then the length rescale factor, and the number of
% levels (total - the first two count in this total)

rule_list_length = num_levels - 2;

number_lists = 2^rule_list_length;

result_matrix = zeros(number_lists, 7);

% display the length and angle values used for the enumeration
lengths_of_branches = length_array
angles_of_branches = angle_array
directions_of_angle_collapse = collapse_array

disp('rule string        centroid_avg      centroid_std     centroid_skewness   entropy   fractal_dimension         endpoint_clashes       steric_clashes');
for i=0:(number_lists-1)
    
    current_iteration = i;
    
    new_rule_array = zeros(1, rule_list_length);
    
    % generate array from binary representation of the number i
    for j=0:(rule_list_length-1)
        if bitand(i , (2^j)) > 0
           new_rule_array(rule_list_length - j) = 1; 
        end
    end
        
    current_rule_array = new_rule_array;
    
    rule_string = '[ ';
    for j=1:rule_list_length
       rule_string = strcat(rule_string, int2str(new_rule_array(j)),' ');
    end
    rule_string = strcat(rule_string, ']');
        
    %L_system_rule_sequence(tempfile, length1, length2, length_rescale, current_rule_array);
    L_system_rule_sequence_variable_length3( tempfile, length_array, current_rule_array )
    
    
    
    %[avg_res, std_res] = btsl_analyze_endpoints_convexhull(tempfile);
    [centroid_dist_avg, centroid_dist_std, centroid_dist_skew, centroid_dist_entropy, fraction_endpoint_clash, fractal_dimension, number_steric_clashes] = btsl_draw_tree_different_angles_13(tempfile, angle_array, collapse_array, 0);
    
    
    result_matrix(i+1,1) = centroid_dist_avg;
    result_matrix(i+1,2) = centroid_dist_std;
    result_matrix(i+1,3) = centroid_dist_skew;
    result_matrix(i+1,4) = centroid_dist_entropy;
    result_matrix(i+1,6) = fraction_endpoint_clash;
    result_matrix(i+1,5) = fractal_dimension;
    result_matrix(i+1,7) = number_steric_clashes;
    
    disp([rule_string, '           ', num2str(centroid_dist_avg), '          ', num2str(centroid_dist_std), '            ', num2str(centroid_dist_skew), '            ', num2str(centroid_dist_entropy), '            ',num2str(fractal_dimension), '                    ', num2str(fraction_endpoint_clash), '                     ', num2str(number_steric_clashes)]);
end

result_list = result_matrix

