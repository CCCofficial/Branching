function [centroid_dist_avg, centroid_dist_std, centroid_dist_skew, centroid_dist_entropy, fraction_endpoint_clash, fractal_dimension, number_of_steric_clashes] = btsl_draw_tree_different_angles_13(infile, angle_vector_degrees, collapse_angle_directions, draw_plots)% modified from version 12 to clean up unused bits of code that had been% commented out as well as to modify the steric clash detection to take% into account Wei's measurements of branch diameter% modified from 11c_fixRotation to add back the other half of the kidney% modified from 11c to NOT accumulate rotations from parent branches, since% Wei's angle changes are based on a global orientation inherited directly% from an earlier branch and not propagated throuh intervening ancestors% testing-only version of 11c which only draws half the tree%  modified from version 11b to check if an angle change direction is%  impossible (meaning, the angles are being asked to collapse in a%  direction that is in-plane with the two branches but perpendicular to%  the parent.   in such a case, do not collapse the angles at all in that%  direction.   it is unclear how to handle cases like this so this%  solution is chosen because it is simplest.% modified from verison 11 to generate the trunk branch and add it to the% overall branch structure.% NOTE:   the collapse orientation vector entries tell how many branching% levels before a given branch the orientation is to be found, that is then% applied to the DAUGHTERS of the branch in question!!!   so ifyou want to% change the angles for a pair of branches relative to their grandparent,% that would be a value of 1 since 0 is the parent!!% modifiecation from verison 10 - now the collapse_angle_directions array% can contain non-negative integers, each of which specified how many% generations back from the parent the reference branch is that determines% the direction of angle collapse.  so, 0 means the direction of the% parent, 1 means direction of the grandparent, 2 means great-grandparent,% and so on.   this will let us explore a wider range of possibilities,% plus in the case that the actual kidney always refers to teh original% trunk branks for all angle changes, this will be able to handle that case% as well as visually indicate how many generationns of orientation data% the system must be keeping track of, if it is only using local% information, which givesn a measure of how much less parsimonious a local% only scheme would become relative to a global positional information% scheme.% note about branch levels.   level 1, called the main branch here, is% actually what Wei called the "secondary" branch, ie. the first set of% branches off of the main trunk.   level 2 is the tertiary branch, which% is the one that is a trifurcation.   so, the whole btsl input file to% this program assumes the main branch is ALREADY PRESENT but implicit.% so there is no main branch in the representation here.   the convention% we used in making the btsl file is that the secondary branch is parallel% to the Z axis (which is why we reflect all coordinates across the XY% plane in this program when we want to make the second half of the% kidney), and then the trifurcations happen parallel to X and -X, plus Z.%  so, the main trunk would be parallel to the Y axis!!!   so, in the case%  that a rotation needs to refer back to the implicit trunk, we need to% either handle that as an exceptional case or else add one more branch% which is the invisible trunk.  it can have as its base 0 -1 0 and as its% end 0 0 0 that would make everythign consistent!% modification from version 9 *** MAJOR MODIFICAITON ****% modified to allow the angle change to take place in either of three% possible direction, which we define by the numbers 1 or 2.%  0 means the angle change takes place so as to make the daughter branches%    more paralell with the parent branch, which is what was done in version%    9 and all previous versions with angle changes.%  1 means the angle change takes place so as to make the daughter branches%    more paralell to the grandparent branch% so, in addition to the angle array, the program will take another input% called collapse_direction_directions which contains values 1 or 2% note:   the first entry has to be 1 because there is no grandparent to% branch parallel to!!!!% note also that certain combinations of branching patterns and angle% collapse orientations are not defined, i..e whenever a branch is paralell to its% grandparent, it is not possible to collapse angles in that direction.% in those cases, the method will spit out zero for all results% modified from verison 8 to also output the skewness of the radial% distance distribution as well as the entropy, since we want to get an% idea of how much all the distances are bunched up at a particular% distance from the centroid.% modified from version 7 to calculate steric clash between all branches% **** NOT WORKING YET ******% usage version 7%btsl_draw_tree_different_angles_7('/Users/wallacemarshall/papers/Wei_branching_simulation/test_file_wholetree_L_000000.txt', [180 180 90 60 60 75 90 120], 1)% modified from version 6 to plot and analyze the distribution of tips in% angle space in spherical coordinates% modified from btsl_draw_tree_different_angles_5 to calculate distance to% nearest neighbor distribution for endpoints as a measure of clash and to% calculate the correlation dimension of the endpoint distribution as a% measure of the fractal dimension of the nephron distribution% usage:% btsl_draw_tree_different_angles_6('/Users/wallacemarshall/papers/Wei_branching_simulation/test_file_wholetree_L_000000.txt', [180 180 90 60 60 75 90 120], 1)% draw_plots is a flag 1 means draw all the figures, 0 means suppress the% figures% modified from v4 to do more spatial statistics% modified from v3 to calculate spatial statistics etc% modified from v 2 to apply rotation to the first branch% modified to read the lengths from the input file% modified from btsl_draw_tree_change_angles5 to allow the angles to all be% different, so instead of taking a single parameter "new angle" it takes a% vector of angles one for each level of branching.   these angles are the% angles BETWEEN the two daughter branches at that level.   also we need to% specify the lengths of each branch.   *** also note that from now on we% should calculate and plot the WHOLE tree, not just starting with B3.   so% our angle and length vecotrs need to have eight elements not six.%  L_system_rule_sequence starts with B1 as the parent branch, in order to%  render and analyze the whole kidney we need to make a copy of the entire%  final structure and reflect it across the Z axis.   so we only need to%  do the calculate for one half of the kidney and then we just generate%  the other half by reflection.% ****** from this version onwards, ALL ANGLES ARE IN DEGREES!!!!%  note about LENGTHS:   all lengths are specified in the L-system rule%  sequence program so we don't worry about them here.   they are%  hard-encoded in the btsl input file.%modified from btsl_draw_tree_change_angles3 to put in the cmyk color% coding scheme from Wei% wei's color code%   branch     c    M    Y     K        converts to:    r      g       b% 3            60   90   0     0                       102      25      255%   4            70    15    0    0                 77       217    255%   5         50  0   100    0                     128      255        0%     6         0   35    85     0                 255     166        38% converted using online calculator:% http://easycalculation.com/colorconverter/rgb-color-converter.php% modified from btsl_analyze_endpoints_convexhull_2 to allow the angles% between branches to change over time as Wei has seen.% only draw the hull if drawhull = 1% modified from btsl_analyze_endpoints_convexhull to only start plotting% with the third branch and then to color each branch according to the% color code to from wei   % wei's color code%   branch     c    M    Y     K% 4            60   90   0     0%   5            70    15    0    0%   6         50  0   100    0%     7         0   35    85     0% so we want to keep track of colors%  since we are starting with the 3rd branch, we will only plot L1.1.1 and%  its children% modified from btsl_analyze_endpoints  to define distance to the surface% based on generating a convex hull containing all the endpoints % modified from btsl_parse_render.   program to take a btsl specification% and analyze the spatial arrangement of the endpoints of all terminal% branches.   for the first siple analysis, take the centroid of all the% terminal points and then measure how far each one is away from the% centroid and then make a histogram of the distances.   as a final value, compute the average distance% of all points from the centroid.%  program to read a branching tissue specification language (btsl) file%  and parse it into a tree representation that can be used to generate%  simulated branch images and analyze the overall organ structure% language format:%  individual branch description:%  {Branch_ID  -L length -D diameter -O orientation (format [a,b,c]) -C%  color -S shift in position (as ratio of full length of parent branch)%     sub_branch_1%     sub_branch_2 ....%   }% example%  {L1 -L   5 -D 10 -O [0, 0, 1] -C r -S 0.5 {  L1.1  -L 4 -D 9 -O [0, 1, 0] -C r -S 0.5}%  {  L1.2  -L 3 -D 8 -O [0, -1, 0] -C r -S 0}%  {  L1.3  -L 2 -D 7 -O [0, 0, 1] -C r -S 0%       {  L1.3.1  -L 2 -D 7 -O [0, 1, 0] -C b -S 0 }%%  }%  }%  tissue:%  Branch_description_x {Branch_description_x_1  }  {Branch_description_x_2%  }   {Branch_description_x3   } ......%   these can be nested infinitely.   a branch can have any number of child%   branches each of which is described by an entry in curly bracesangle_vector = angle_vector_degrees*pi/180;new_angle = angle_vector(2);valid_matrix = 1;  % will use for testing if angle collapse is possibleinvalid_matrix_detected = 0;fid = fopen(infile);current_object = 0;xvals = zeros(256,1000);xvalsL = zeros(256,1000);  % assuming max 20 objects max 100 points per objectxvalsR = zeros(256,1000);yvals = zeros(256,1000);zvals = zeros(256,1000);numpoints = zeros(256,1);numlines = 0;big_string = '';% read the whole file in as one huge stringtline = fgetl(fid); % read line and remove newlinewhile ischar(tline)        if ~strncmp(tline, '%', 2) % check for comment lines      numlines = numlines + 1;      big_string = strcat(big_string, ' ', tline);    end        tline = fgets(fid);endnum_branches = length(regexp (big_string, '{'));numpoints = zeros(1,num_branches);   % keeps track of how many points to render for each branchbranch_lengths = zeros(1,num_branches);  % length of each branchendpoint_x = zeros(1,num_branches);  % keep track of endpoint coordinates for each branchendpoint_y = zeros(1,num_branches);endpoint_z = zeros(1,num_branches);startpoint_x = zeros(1,num_branches);  % keep track of endpoint coordinates for each branchstartpoint_y = zeros(1,num_branches);startpoint_z = zeros(1,num_branches);dx = zeros(1,num_branches); % components of normal vector tracking each branch orientationdy = zeros(1,num_branches);dz = zeros(1,num_branches);branch_direction = zeros(num_branches,3);  % will store orientation for each branch in advancebranch_shift = zeros(1,num_branches); % fraction of length of parent branch to sprout daughter branchbranch_colors = zeros(1,num_branches);branch_parent = zeros(1, num_branches);branch_radius = zeros(1, num_branches);isa_parent = zeros(num_branches, 1);distance_from_centroid = zeros(1, num_branches);% pad any non-space delimiters so that when we split the string into tokens% based on spaces, everything gets splitbig_string = regexprep(big_string, '{', ' { ');big_string = regexprep(big_string, '}', ' } ');big_string = regexprep(big_string, '[', ' [ ');big_string = regexprep(big_string, ']', ' ] ');big_string = regexprep(big_string, ',', ' , ');% now trim out any multiple white spaces otherwise we end up with tokens% that are just a string of spacesbig_string = regexprep(big_string, '\s+', ' ');btsl_words = regexp(big_string, ' ', 'split');num_words = length(btsl_words);branch_parent(1) = 0;new_branch = 0;current_level = 1;current_parent = 0;current_branch_ID = 0;parent_stack = zeros(1, num_branches);stack_pointer = 1;[parent_stack, stack_pointer] = push(parent_stack, stack_pointer, 0);for i=1:num_words        if new_branch == 1        new_branch = 0;                current_branch_ID = current_branch_ID + 1;  % create a new branch ID for each new branch when defined        branch_parent(current_branch_ID) = current_parent;        % now we have to make this branch the parent for any subsequent        % sub-branches        current_parent = current_branch_ID;                    else        if strncmp(btsl_words(i), '{', 1)            current_level = current_level +1;            new_branch = 1;            now_the_parent_is = current_parent;            [parent_stack, stack_pointer] = push(parent_stack, stack_pointer, current_parent);        elseif strncmp(btsl_words(i), '}', 1)            current_level = current_level - 1;            [parent_stack, stack_pointer, current_parent] = pop(parent_stack, stack_pointer);            now_the_parent_is = current_parent;        elseif strncmp(btsl_words(i), '-D', 2)            number_string = char(btsl_words(i+1)); % convert from cell to character string            branch_radius(current_branch_ID) = sscanf(number_string, '%u');        elseif strncmp(btsl_words(i), '-L', 2)            number_string = char(btsl_words(i+1)); % convert from cell to character string            branch_lengths(current_branch_ID) = sscanf(number_string, '%f');        elseif strncmp(btsl_words(i), '-S', 2)            number_string = char(btsl_words(i+1)); % convert from cell to character string            branch_shift(current_branch_ID) = sscanf(number_string, '%f');        elseif strncmp(btsl_words(i), '-C', 2)            number_string = char(btsl_words(i+1)); % convert from cell to character string            branch_color(current_branch_ID) = number_string;         elseif strncmp(btsl_words(i), '[', 1)            number_string1 = char(btsl_words(i+1)); % convert from cell to character string            number_string2 = char(btsl_words(i+3));            number_string3 = char(btsl_words(i+5));            branch_direction(current_branch_ID, 1) = sscanf(number_string1, '%f');            branch_direction(current_branch_ID, 2) = sscanf(number_string2, '%f');            branch_direction(current_branch_ID, 3) = sscanf(number_string3, '%f');        end    endend% add the trunk branch, which is parallel to the Y axis and ends at 000num_branches = num_branches + 1;branch_lengths(num_branches) = 100;branch_direction(num_branches, 1) = 0;branch_direction(num_branches, 2) = 1;branch_direction(num_branches, 3) = 0;branch_parent(1) = num_branches;branch_parent(num_branches) = 0;branch_color(num_branches) = 'b';branch_radius(num_branches) = 1;for i=1:num_branches    numpoints(i) = 100;end% calculate the coordinates of the root (actually what Wei calls the "secondary") branchfor j=1:numpoints(1)        xvals(1,j) = branch_lengths(1)*branch_direction(1,1)*(double(j)/double(numpoints(1)));        yvals(1,j) = branch_lengths(1)*branch_direction(1,2)*(double(j)/double(numpoints(1)));        zvals(1,j) = branch_lengths(1)*branch_direction(1,3)*(double(j)/double(numpoints(1)));end% calculate coordinates of the actual trunk for j=1:numpoints(num_branches)          xvals(num_branches,j) = branch_lengths(num_branches)*branch_direction(num_branches,1)*(double(j)/double(numpoints(num_branches)));        yvals(num_branches,j) = branch_lengths(num_branches)*branch_direction(num_branches,2)*(double(j)/double(numpoints(num_branches))) - 100;        zvals(num_branches,j) = branch_lengths(num_branches)*branch_direction(num_branches,3)*(double(j)/double(numpoints(num_branches)));end% calculate the coordinates of the other branchesfor i=2:(num_branches-1)    parent_numpoints = numpoints(branch_parent(i));  % for calculating shifted start position    parent_startpoint = round(double(parent_numpoints)*double(branch_shift(i)));  % calculate shifted start position on parent    if parent_startpoint == 0  % check for any arithmetical mistakes in parent start point        parent_startpoint = 1;    end    if parent_startpoint > numpoints(branch_parent(i))        parent_startpoint = numpoints(branch_parent(i));    end    for j=1:numpoints(i)        xvals(i,j) = xvals(branch_parent(i),parent_startpoint) + branch_lengths(i)*branch_direction(i,1)*(double(j)/double(numpoints(i)));        yvals(i,j) = yvals(branch_parent(i),parent_startpoint) + branch_lengths(i)*branch_direction(i,2)*(double(j)/double(numpoints(i)));        zvals(i,j) = zvals(branch_parent(i),parent_startpoint) + branch_lengths(i)*branch_direction(i,3)*(double(j)/double(numpoints(i)));    endendfor i=1:num_branches        % draw branch as a lineX1 = xvals(i,1:numpoints(i));Y1 = yvals(i,1:numpoints(i));Z1 = zvals(i,1:numpoints(i));% now compute endpoints and orientation of each branchendpoint_x(i) = xvals(i,numpoints(i));endpoint_y(i) = yvals(i,numpoints(i));endpoint_z(i) = zvals(i,numpoints(i));startpoint_x(i) = xvals(i,1);startpoint_y(i) = yvals(i,1);startpoint_z(i) = zvals(i,1);% find orientation vectordx_total = endpoint_x(i) - startpoint_x(i);dy_total = endpoint_y(i) - startpoint_y(i);dz_total = endpoint_z(i) - startpoint_z(i);% convert to unit vectordx(i) = dx_total/sqrt(dx_total^2 + dy_total^2 + dz_total^2);dy(i) = dy_total/sqrt(dx_total^2 + dy_total^2 + dz_total^2);dz(i) = dz_total/sqrt(dx_total^2 + dy_total^2 + dz_total^2);end% start by setting up some data structures to describe the treedaughters = find_daughters(branch_parent);terminals = find_terminal_branches(daughters);ancestors = find_ancestor_array(branch_parent);branching_level = find_branch_level(branch_parent);terminal_branch_level = max(branching_level);% get a vector representation for each branchfor i=1:num_branches    dx_total = endpoint_x(i) - startpoint_x(i);    dy_total = endpoint_y(i) - startpoint_y(i);    dz_total = endpoint_z(i) - startpoint_z(i);    branch_vector{i} = [dx_total, dy_total, dz_total];     branch_base{i} = [startpoint_x(i), startpoint_y(i), startpoint_z(i)];end% algorithm:%   phase 1.   pre-compute rotation matrices%    for each branch check if it is a terminal branch%       if it is, do nothing%       if not, check if it is a trifurcation, if it is, store the identity%       matrix as the rotation matrix for each of the three daughters%     find both daughters from the daugthers structure we just computed%     calculate the rotation matrix that should be applied to collapse%     those two daughters to the desired angle%     for each daughter, store the rotation matrix that needs to be applied%     to that particuilar daughter.   so we end up with an array where%     there is a rotation matrix for every branch.%%     keep doing this until all branches have been checked.%     these rotation matrices store the rotations that have to be applied%     at each particular branch on top of any other rotations that might%     occur%%  phase 2.   accumulate rotations%     for each branch, step through the ancestors list and find the%     rotation matrix for each ancestor.   multipyl them all together and%     then multiply the final product with the rotation matrix for the%     branch in question.   this is the total rotation for that branch%     note:   this phase was used in earlier versions of the program but in%     this version we do not accumulate rotations because the new%     angle-collapse method is in reference to a global orientation.  i am%     leaving the notation about phase 2 in place for consistency with%     earlier versions.%%   phase 3.   find all the new vectors%      for each branch, take its original vector value and rotate by the%      total rotation for that branch.  %%   phase 3  find the new base-points for every vectorident_matrix = eye(3,3);  % identity matrix for storingbranch_rotation{1} = ident_matrix;  % root branch doesn't get rotated% phase 1 - compute rotation matrices for daughtersfor i=1:(num_branches-1) % iterate over all branches        if terminals(i) == 0 % ignore terminal branches        new_angle = angle_vector(branching_level(daughters(i,1)) - 1);   % subtract one because the trunk doens't count as a branching level        collapse_orientation = collapse_angle_directions(branching_level(daughters(i,1)) - 1);        % collapse_orientation determines if we collapse angles parellel to        % parent or grandparent        if (collapse_orientation == 1) && (branch_parent(i) > 0) % collapse parallel to the grandparent not parent            collapse_vector = branch_vector(branch_parent(i));  % grandparent vector        elseif  (collapse_orientation == 2) && (branch_parent(branch_parent(i)) > 0)            collapse_vector = branch_vector( branch_parent(branch_parent(i)) );        elseif  (collapse_orientation == 3) && (branch_parent(branch_parent(branch_parent(i))) > 0)            collapse_vector = branch_vector( branch_parent(branch_parent(branch_parent(i))) );        elseif  (collapse_orientation == 4) && (branch_parent(branch_parent(branch_parent(branch_parent(i)))) > 0)            collapse_vector = branch_vector( branch_parent(branch_parent(branch_parent(branch_parent(i)))) );           elseif  (collapse_orientation == 5) && (branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i))))) > 0)            collapse_vector = branch_vector( branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i))))) );        elseif  (collapse_orientation == 6) && (branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i)))))) > 0)            collapse_vector = branch_vector( branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i)))))) );            elseif  (collapse_orientation == 7) && (branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i))))))) > 0)            collapse_vector = branch_vector( branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i))))))) );         elseif  (collapse_orientation == 8) && (branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i)))))))) > 0)            collapse_vector = branch_vector( branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i)))))))) );          elseif  (collapse_orientation == 9) && (branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i))))))))) > 0)            collapse_vector = branch_vector( branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i))))))))) );              elseif  (collapse_orientation == 10) && (branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i)))))))))) > 0)            collapse_vector = branch_vector( branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(branch_parent(i)))))))))) );               elseif (collapse_orientation == 0)            collapse_vector = branch_vector(i); % parent vector        else            collapse_vector = branch_vector(i); % parent vector            invalid_matrix_detected = 1  % a non-existent reference branch was specified so this run needs to be discarded            value_of_i = i            collapse_orientation_is = collapse_orientation        end                                        if daughters(i,3) > 0 % trifurcation            % need to figure out which one is the central branch and                % rotate the other two            A = cell2mat(branch_vector(i)); % we still want to use this for testing which branches in a trifurcation to change            B = cell2mat(branch_vector(daughters(i,1)));            C = cell2mat(branch_vector(daughters(i,2)));            D = cell2mat(branch_vector(daughters(i,3)));                        if abs(dot(A,B)) > 0                branch_rotation{daughters(i,1)} = ident_matrix;                [R1, R2, valid_matrix] = collapse_angles(cell2mat(branch_base(i)), cell2mat(collapse_vector), cell2mat(branch_vector(daughters(i,2))), cell2mat(branch_vector(daughters(i,3))), new_angle);                if valid_matrix == 0                    % invalid_matrix_detected = 1;                    R1 = ident_matrix;                    R2 = ident_matrix;                end                branch_rotation{daughters(i,2)} = R1;                branch_rotation{daughters(i,3)} = R2;                        elseif abs(dot(A,C)) > 0                branch_rotation{daughters(i,2)} = ident_matrix;                [R1, R2, valid_matrix] = collapse_angles(cell2mat(branch_base(i)), cell2mat(collapse_vector), cell2mat(branch_vector(daughters(i,1))), cell2mat(branch_vector(daughters(i,3))), new_angle);                if valid_matrix == 0                    % invalid_matrix_detected = 1;                    R1 = ident_matrix;                    R2 = ident_matrix;                end                branch_rotation{daughters(i,1)} = R1;                branch_rotation{daughters(i,3)} = R2;                                   elseif abs(dot(A,D)) > 0                branch_rotation{daughters(i,3)} = ident_matrix;                [R1, R2, valid_matrix] = collapse_angles(cell2mat(branch_base(i)), cell2mat(collapse_vector), cell2mat(branch_vector(daughters(i,1))), cell2mat(branch_vector(daughters(i,2))), new_angle);                if valid_matrix == 0                    %invalid_matrix_detected = 1;                    R1 = ident_matrix;                    R2 = ident_matrix;                end                branch_rotation{daughters(i,1)} = R1;                branch_rotation{daughters(i,2)} = R2;            else                for j=1:3                    branch_rotation{daughters(i,j)} = ident_matrix;                end            end                                                       else                        [R1, R2, valid_matrix] = collapse_angles(cell2mat(branch_base(i)), cell2mat(collapse_vector), cell2mat(branch_vector(daughters(i,1))), cell2mat(branch_vector(daughters(i,2))), new_angle);            if valid_matrix == 0               % invalid_matrix_detected = 1;  in this case we choose not               % to collapse the angles               R1 = ident_matrix;               R2 = ident_matrix;            end            %returned_matrx = R2                        branch_rotation{daughters(i,1)} = R1;            branch_rotation{daughters(i,2)} = R2;            % branch_rotation{daughters(i,3)} = ident_matrix;  % should never be used        end    end    endif invalid_matrix_detected == 1 % signifies an impossible combination of branching patterna and angle collapse directions    centroid_dist_avg = 0;    centroid_dist_std = 0;    centroid_dist_skew = 0;     centroid_dist_entropy = 0;     fraction_endpoint_clash = 0;     fractal_dimension = 0;     number_of_steric_clashes = 0;    return;   % exit from program, returning all zeros to indicate failureend% phase 2 - apply the rotationsfor i=1:num_branches         if i == num_branches        rot_product = ident_matrix;    else        % rot_product = cell2mat(branch_rotation(i))*rot_product;  this was        % the rotation accumulation used in earlier versions of the        % programwhere angle collapse was strictly determined by parent        % branches.  but this is not consistent with what Wei sees so now        % the collapse direction is globally determined and so we dont        % want to accumulate the angles any more        rot_product = cell2mat(branch_rotation(i));    end        new_branch_vector{i} = cell2mat(branch_vector(i))*rot_product; % phase 3 built-in        end% phase 4 find the base points for every branch now that everything is% rotatedfor i=1:num_branches    total_translation = [0, 0, 0];  % initialize    for j=1:(num_branches-1)       if ancestors(i,j) > 0           total_translation = cell2mat(new_branch_vector(j)) + total_translation;       end    end            new_branch_base{i} = total_translation;end% so at this point we have calculated all the branch vectors for half a% kidney, starting with the B1 branch that points in the direction of% positive Z.    now we need to make a copy in which all the Z values are% reflected across the XY plane but otherwise everything is the same.copy_branching_level = branching_level;copy_new_branch_base = new_branch_base;copy_new_branch_vector = new_branch_vector;copy_terminals = terminals;reflection_matrix = [1 0 0 ; 0 1 0 ; 0 0 -1];  % reflect across XY planefor i=1:num_branches    copy_new_branch_vector{i} = cell2mat(new_branch_vector(i))*reflection_matrix;    copy_new_branch_base{i} = cell2mat(new_branch_base(i))*reflection_matrix;   endif draw_plots == 1figure;hold on;axis equal;rotate3d on;for i=1:num_branches    current_branch_level = branching_level(i);    colorcode = find_color(current_branch_level, terminal_branch_level);    draw_vector(cell2mat(new_branch_base(i)), cell2mat(new_branch_vector(i)), colorcode);endfigure;hold on;axis equal;rotate3d on;for i=1:num_branches    current_branch_level = copy_branching_level(i);    colorcode = find_color(current_branch_level, terminal_branch_level);    draw_vector(cell2mat(copy_new_branch_base(i)), cell2mat(copy_new_branch_vector(i)), colorcode);endend  % draw plots% now merge the two half-kidneys into a whole kidney% at this stage, we can finaly apply the rotation to the B1 branchwhole_kidney_num_branches = num_branches*2;rotation_axis = [1 0 0];  % B1 is 0 0 1, B0 is 0 1 0 so we want to rotate arouind the third orthogonal axisangle_offset = pi - angle_vector(1);R1 = rotationmat3D(angle_offset, rotation_axis);R2 = rotationmat3D(-angle_offset, rotation_axis);for i=1:num_branches    new_branch_vector{i} = cell2mat(new_branch_vector(i))*R1;    new_branch_base{i} = cell2mat(new_branch_base(i))*R1;    copy_new_branch_vector{i} = cell2mat(copy_new_branch_vector(i))*R2;    copy_new_branch_base{i} = cell2mat(copy_new_branch_base(i))*R2;   endfor i=1:num_branches    whole_kidney_branch_base(i) = new_branch_base(i);    whole_kidney_branch_vector(i) = new_branch_vector(i);    whole_kidney_branching_level(i) = branching_level(i);    whole_kidney_terminals(i) = terminals(i);endfor i=1:num_branches    whole_kidney_branch_base(i+num_branches) = copy_new_branch_base(i);    whole_kidney_branch_vector(i+num_branches) = copy_new_branch_vector(i);    whole_kidney_branching_level(i+num_branches) = copy_branching_level(i);    whole_kidney_terminals(i+num_branches) = copy_terminals(i);endif draw_plots == 1 figure;hold on;axis equal;rotate3d on;for i=1:whole_kidney_num_branches    current_branch_level = whole_kidney_branching_level(i);    colorcode = find_color(current_branch_level, terminal_branch_level);    draw_vector(cell2mat(whole_kidney_branch_base(i)), cell2mat(whole_kidney_branch_vector(i)), colorcode);endend% locate all the terminal end-pointstemporar_base_vectors = cell2mat(whole_kidney_branch_base);temporary_branch_vector = cell2mat(whole_kidney_branch_vector);endpoint = zeros(num_branches*2, 3);% now find the set of  all end-points so we can do spatial statisticsj = 0; % counter for terminal pointsfor i=1:num_branches*2   % endpoint{i} = cell2mat(whole_kidney_branch_base(i)) + cell2mat(whole_kidney_branch_vector(i));   if whole_kidney_terminals(i) == 1        j = j+1;  % counter for terminal points        base_vector_temp = cell2mat(whole_kidney_branch_base(i));        branch_vector_temp = cell2mat(whole_kidney_branch_vector(i));        endpoint(j,1) = base_vector_temp(1) + branch_vector_temp(1);        endpoint(j,2) = base_vector_temp(2) + branch_vector_temp(2);        endpoint(j,3) = base_vector_temp(3) + branch_vector_temp(3);        terminal_branch_length = sqrt(branch_vector_temp(1)^2 + branch_vector_temp(2)^2 + branch_vector_temp(3)^2); % will use this later for spatial statistics   endend%set_of_endpoints = endpointendpoint_x = endpoint(1:j, 1);endpoint_y = endpoint(1:j, 2);endpoint_z = endpoint(1:j, 3);if draw_plots == 1plot3(endpoint_x,endpoint_y,endpoint_z,'or');endnum_endpoints = j;% ************************** Spatial Statistics *******************%***********************************************************************% First spatial statistical analysis:  distance distribution relative to% centroid% locate centroidxsum = 0;ysum = 0;zsum = 0;for i=1:num_endpoints    xsum = xsum + endpoint_x(i);    ysum = ysum + endpoint_y(i);    zsum = zsum + endpoint_z(i);endxcen = xsum/num_endpoints;ycen = ysum/num_endpoints;zcen = zsum/num_endpoints;max_radial = 0;for i=1:num_endpoints    distances(i) = sqrt( ( endpoint_x(i) - xcen)^2 + (endpoint_y(i) - ycen)^2 + (endpoint_z(i) - zcen)^2);    if distances(i) > max_radial        max_radial = distances(i); % for getting bins to compue entropy    endendif draw_plots == 1figure;hist(distances,20); % distance from centroid of terminal pointsendcentroid_dist_avg = mean(distances);centroid_dist_std = std(distances);centroid_dist_skew = skewness(distances);% compute entropynum_intervals = 20;entropy_bins = zeros(num_intervals, 1);for i=1:num_endpoints        dist_index = round(num_intervals*(distances(i)/max_radial));        if dist_index == 0            dist_index = 1;        end        if dist_index < 1            dist_index = 1;        end        if dist_index > num_intervals            dist_index = num_intervals;        end        entropy_bins(dist_index) = entropy_bins(dist_index) + 1; % update all intervals whose distance corresponds to a distance larger than the current oneendentropy = 0;for i=1:num_intervals    prob_bin = entropy_bins(i)/num_endpoints;    if prob_bin > 0      entropy = entropy - prob_bin*log(prob_bin);     endendcentroid_dist_entropy = entropy;% plot angular distribution of endpointsendpoint_theta = zeros(num_endpoints, 1);endpoint_phi = zeros(num_endpoints, 1);endpoint_mollweide_x = zeros(num_endpoints, 1);endpoint_mollweide_y = zeros(num_endpoints, 1);for i=1:num_endpoints    dist_point = sqrt( ( endpoint_x(i) - xcen)^2 + (endpoint_y(i) - ycen)^2 + (endpoint_z(i) - zcen)^2);    endpoint_phi(i) = acos(endpoint_z(i)/dist_point);    endpoint_theta(i) = atan(endpoint_y(i)/endpoint_x(i));        [projected_x, projected_y] = mollweide_projection(endpoint_theta(i), endpoint_phi(i));        endpoint_mollweide_x(i) = projected_x;    endpoint_mollweide_y(i) = projected_y;    endif draw_plots == 1figure;plot(endpoint_theta, endpoint_phi, 'or');title({'endpoints in angle space, x=theta y=phi'});figure;plot(endpoint_mollweide_x, endpoint_mollweide_y, 'or', 'MarkerFaceColor', 'r');hold on;title({'Mollweide Projection of endpoints'});drawline_mollweide_x = zeros(100, 1);drawline_mollweide_y = zeros(100, 1);for i=-4:4    line_theta = (pi/8)*i;    for j=1:100        line_phi = (pi/100)*j;        [projected_x, projected_y] = mollweide_projection(line_theta, line_phi);        drawline_mollweide_x(j) = projected_x;        drawline_mollweide_y(j) = projected_y;    end    plot(drawline_mollweide_x, drawline_mollweide_y, 'b');endend % if_draw_plots%*********************************************************% Second spatial statistical analysis:%**** distribution of endpoint nearest neightbor distancesmax_distance = 0; % save this for later use in correlation dimension belowfor i=1:num_endpoints    min_dist = 10000000;    for j=1:num_endpoints        dist_point = sqrt( ( endpoint_x(i) - endpoint_x(j))^2 + (endpoint_y(i) - endpoint_y(j))^2 + (endpoint_z(i) - endpoint_z(j))^2);        if dist_point > max_distance            max_distance = dist_point; % save this for later in the correlation dimension calculation below        end        if (dist_point < min_dist) && (i ~= j)            min_dist = dist_point;        end    end    distances(i) = min_dist;endif draw_plots == 1figure;hist(distances,20); % distance from each point to its nearest neighborendneighbor_dist_avg = mean(distances);neighbor_dist_std = std(distances);% but note that these numbers themsevles don't mean much since most of the% time the nearest neighbor may be the sister.   so what we really want to% know is how often the nearest neighbor is not a sister.% for reference we should calculate the distance between sister endpoints.%  we can do this give the final angle and branch lengths.last_angle_index = length(angle_vector);final_angle = angle_vector(last_angle_index);each_branch_length = terminal_branch_length;% calculate distance by splitting the total angle into two half angles each% of which forms a right triangle whose hypoteneuse is a terminal branchsister_distance = 2*terminal_branch_length*sin(final_angle/2);% now calculate how many termini have a closest neightbor that is closer% than their own sister, which is a measure of how much clash or% entanglement there is.%  take the cutoff to be 95% of the sister distance to avoid small%  numerical fluctuations of the actual sister distance sthrowing it all%  off.num_closer = 0;for i=1:num_endpoints    if distances(i) < 0.95*sister_distance        num_closer = num_closer + 1;    endendfraction_endpoint_clash = num_closer / num_endpoints;%********************************************************************%*** Third spatial statistic:%****** estimate dimensionality of terminal point set by correlation%dimensionnum_intervals = 50;distance_counts = zeros(num_intervals,1);maximum_distance = max_distance;    for i=1:(num_endpoints - 1)        for j=(i+1):num_endpoints        dist_point = sqrt( ( endpoint_x(i) - endpoint_x(j))^2 + (endpoint_y(i) - endpoint_y(j))^2 + (endpoint_z(i) - endpoint_z(j))^2);        dist_index = round(num_intervals*(dist_point/max_distance));        if dist_index == 0            dist_index = 1;        end        for k=dist_index:num_intervals            distance_counts(k) = distance_counts(k) + 1; % update all intervals whose distance corresponds to a distance larger than the current one        end    endenddistance_counts_result = distance_counts;% to avoid NaN in case there are no counts in one binfor i=1:num_intervals    if distance_counts(i) == 0        distance_counts(i) = 1;    endendif draw_plots == 1figure;plot(distance_counts);endinterval_array = [1:num_intervals]';logcounts = log(distance_counts);logindexes = log(interval_array);if draw_plots == 1figure;plot(logindexes,logcounts); end% calculate scaling exponent using first half of the data range% exclude the very first points since they can be flaky due to spacing% issuesp = polyfit(logindexes(3:20), logcounts(3:20), 1);correlation_dimension = p(1);fractal_dimension = correlation_dimension;%******************************************************% ***  Steric Clash analysis ******%*****************************************************% make a figure to show the clashing branchesif draw_plots == 1     figure;    hold on;    axis equal;    rotate3d on;    for i=1:whole_kidney_num_branches        current_branch_level = whole_kidney_branching_level(i);        colorcode = find_color(current_branch_level, terminal_branch_level);        draw_vector(cell2mat(whole_kidney_branch_base(i)), cell2mat(whole_kidney_branch_vector(i)), colorcode);    endendnum_clashes = 0;total_tests_for_clash = 0;% we need a way to define how close is close.% Wei has measured the diameter of the branches to be roughly 50 microns% so if two branches approach each other with a minimuym distance of less% than 50 that would mean a clash.% note:  earlier versions defined the clash range in terms of the average% branch length as follows:       %avg_branch_length = mean(branch_lengths);       %clash_range = 0.05 * avg_branch_length; % tubes are about 5% as wide as they are long ???clash_range = 50;for i=1:(whole_kidney_num_branches-1)for j=(i+1):whole_kidney_num_branches if (i ~= j)  % only consider non-equal branches    % but we also need to make it only consider branches that aren't    % children of each other, since those will always come close at their    % common vertex    % as a simply approximation, we can test on    % whole_kidney_branching_level and only take pairs that aren't at    % adjacent branching levels    %branching_level_difference = abs(whole_kidney_branching_level(i) - whole_kidney_branching_level(j));    %if branching_level_difference ~= 1  % so same level is OK, or bigger level differences                base1 = cell2mat(whole_kidney_branch_base(i));        base2 = cell2mat(whole_kidney_branch_base(j));        vector1 = cell2mat(whole_kidney_branch_vector(i));        vector2 = cell2mat(whole_kidney_branch_vector(j));                % check if one is the parent of the other        x1 = base1(1) + vector1(1);        x2 = base2(1) + vector2(1);        y1 = base1(2) + vector1(2);        y2 = base2(2) + vector2(2);        z1 = base1(3) + vector1(3);        z2 = base2(3) + vector2(3);        dist_1_2 = sqrt((x1-base2(1))^2 + (y1-base2(2))^2 + (z1-base2(3))^2); % dist from end of 1 to start of 2        dist_2_1 = sqrt((x2-base1(1))^2 + (y2-base1(2))^2 + (z2-base1(3))^2); % dist from end of 2 to start of 1        dist_1_1 = sqrt((base1(1)-base2(1))^2 + (base1(2)-base2(2))^2 + (base1(3)-base2(3))^2); % dist from start of 1 to start of 2        dist_2_2 = sqrt((x1-x2)^2 + (y1-y2)^2 + (z1-z2)^2); % dist from end of 1 to endt of 2                if (dist_1_2 > 0.1) && (dist_2_1 > 0.1) && (dist_1_1 > 0.1) && (dist_2_2 > 0.1)  % to avoid roundoff error effects we use a value slightly larger than zero             %draw_vector(cell2mat(whole_kidney_branch_base(i)), cell2mat(whole_kidney_branch_vector(i)), colorcode);            clash_detected = 0;            total_tests_for_clash = total_tests_for_clash + 1;            for m=0:10            for n=0:10                x1 = base1(1) + vector1(1)*(m/10.0);                x2 = base2(1) + vector2(1)*(n/10.0);                y1 = base1(2) + vector1(2)*(m/10.0);                y2 = base2(2) + vector2(2)*(n/10.0);                z1 = base1(3) + vector1(3)*(m/10.0);                z2 = base2(3) + vector2(3)*(n/10.0);                dist_m_n = sqrt((x1-x2)^2 + (y1-y2)^2 + (z1-z2)^2);                if dist_m_n < clash_range                    clash_detected = 1;                end                        end            end            if clash_detected == 1                num_clashes = num_clashes + 1;                if draw_plots == 1                    draw_vector(cell2mat(whole_kidney_branch_base(i)), cell2mat(whole_kidney_branch_vector(i)), 'r');                end            end                end % test to make sure they aren't parent-child branchesendendendnumber_of_steric_clashes = num_clashes;total_number_branches = whole_kidney_num_branches;max_number_possible_clashes = total_tests_for_clash;dist_avg = mean(distances);dist_std = std(distances);end%**************************************************************************%**************************************************************************% stack data structure for storing pointers to parent branches% used in the parserfunction [new_stack, current_pointer] = push(old_stack, old_pointer, new_data)current_pointer = old_pointer + 1;revised_stack = old_stack;revised_stack(current_pointer) = new_data;new_stack = revised_stack;endfunction [new_stack, current_pointer, new_data] = pop(old_stack, old_pointer)new_data = old_stack(old_pointer);current_pointer = old_pointer - 1;new_stack = old_stack;endfunction R= rotationmat3D(r,Axis)%function R= rotationmat3D(radians,Axis)%% creates a rotation matrix such that R * x % operates on x by rotating x around the origin r radians around line% connecting the origin to the point "Axis"%% example:% rotate around a random direction a random amount and then back% the result should be an Identity matrix%%r = rand(4,1);%rotationmat3D(r(1),[r(2),r(3),r(4)]) * rotationmat3D(-r(1),[r(2),r(3),r(4)])%% example2: % rotate around z axis 45 degrees% Rtest = rotationmat3D(pi/4,[0 0 1])%%Bileschi 2009L = norm(Axis);if (L < eps)   error('axis direction must be non-zero vector');endAxis = Axis / L;L = 1;u = Axis(1);v = Axis(2);w = Axis(3);u2 = u^2;v2 = v^2;w2 = w^2;c = cos(r);s = sin(r);%storageR = nan(3);%fillR(1,1) =  u2 + (v2 + w2)*c;R(1,2) = u*v*(1-c) - w*s;R(1,3) = u*w*(1-c) + v*s;R(2,1) = u*v*(1-c) + w*s;R(2,2) = v2 + (u2+w2)*c;R(2,3) = v*w*(1-c) - u*s;R(3,1) = u*w*(1-c) - v*s;R(3,2) = v*w*(1-c)+u*s;R(3,3) = w2 + (u2+v2)*c;endfunction  colorcode = find_color(branch_level, terminal_branch_level)% performs table lookup to get the branch color code vector using Wei's% coloring scheme   % if branch_level == terminal_branch_level   %     colorcode = [1, 166/255, 38/255];   % elseif branch_level == terminal_branch_level -1   %     colorcode = [128/255, 1, 0];   % elseif branch_level == terminal_branch_level -2   %     colorcode = [77/255, 217/255, 1];   % elseif branch_level == terminal_branch_level -3       % colorcode = [102/255, 25/255, 1];   %    colorcode = [102/255, 25/255, 120/255];       % else   %     colorcode = [0, 0, 0];   %end         if branch_level == terminal_branch_level % branch level 9 purple        colorcode = [0.4940, 0.1840, 0.5560];    elseif branch_level == terminal_branch_level -1 % branch 8 blue green        colorcode = [0, 0.75, 0.75];    elseif branch_level == terminal_branch_level -2  % branch 7 red        colorcode = [1, 0, 0];    elseif branch_level == terminal_branch_level -3  % branch 6 orange       % colorcode = [102/255, 25/255, 1];       colorcode = [0.9290, 0.6940, 0.1250];    elseif branch_level == terminal_branch_level -4  % branch 5 green        colorcode = [0, 0.5, 0];    elseif branch_level == terminal_branch_level -5  % branch 4 blue        colorcode = [0, 0, 1];    elseif branch_level == terminal_branch_level -6  % branch 3 tertiary light blue        colorcode = [0.3010, 0.7450, 0.9330];    elseif branch_level == terminal_branch_level -7  % branch 2 pink        colorcode = [1, 0, 1];    else        colorcode = [0.5, 0.5, 0];  % main trunk primary branch yellow    endendfunction   draw_vector(base_position_vector, vector_to_plot, vector_color)%  draws a line starting at the point defined by base position vector with%  a length and direction definfed by vector to plot, of the specified%  color. it is assumed that both vectors are 3D row vectorstestlinex = zeros(1,2);testliney = zeros(1,2);testlinez = zeros(1,2);testlinex(1,1) = base_position_vector(1);testliney(1,1) = base_position_vector(2);testlinez(1,1) = base_position_vector(3);endpoint_vector = base_position_vector + vector_to_plot;testlinex(1,2) = endpoint_vector(1);testliney(1,2) = endpoint_vector(2);testlinez(1,2) = endpoint_vector(3);X1 = testlinex(1, 1:2);Y1 = testliney(1, 1:2);Z1 = testlinez(1, 1:2);plot3(X1,Y1,Z1,'Color',vector_color, 'LineWidth', 4);endfunction  [R1 R2 valid_matrix] = collapse_angles(parent_base, parent_vector, daughter_vector1, daughter_vector2, angle)%  computes the rotation matrices to be applied to the two daughter branches, along with all of their descendents, %  in order to collapse the angle between the two daughters to be equal to%  angleif norm( cross(parent_vector, daughter_vector1) ) > 0parent_endpoint = parent_base + parent_vector;daughter_base = parent_endpoint;rotation_axis1 = cross(parent_vector, daughter_vector1)./norm( cross(parent_vector, daughter_vector1) );angle_to_daughter1 = asin( norm(cross(parent_vector, daughter_vector1)) / ( norm(parent_vector)*norm(daughter_vector1)    )  );theta_goal = pi/4;  % this is the angle we want between the daughter and the direction of the parentangle_offset = angle_to_daughter1 - angle/2; % how much rotation to reduce the difference to the goal angle% the goal angle is where each daughter makes an equal angle with the% direction of the parent so that their sum adds up to the target value% "angle"R1 = rotationmat3D(angle_offset, rotation_axis1); % rotate daughter 1R2 = rotationmat3D(-angle_offset, rotation_axis1);  % rotate daughter 2 the same extent in the other directionvalid_matrix = 1;else        R1 = eye(3,3);    R2 = eye(3,3);    valid_matrix = 0;end        endfunction daughter_link = find_daughters(parent)% takes the array of parent pointers and returns an array of daughter% pointers, where for each parent there are two or three daughters.   if% there are only two daughters, the third daughter link will be set to zero% which is never a valid branch identifier.numentries = length(parent);% first fill an array to indicate all the daughter relationshipsdaughter_status=zeros(numentries);for i=1:numentries    for j=1:numentries                if parent(i) == j            daughter_status(i,j) = 1;        end            endenddaughter_link = zeros(numentries, 3);for i=1:numentries    found_first = 0;    found_second = 0;    for j=1:numentries        if (daughter_status(j,i) == 1)            if (found_first == 0) && (found_second == 0)                daughter_link(i,1) = j;                found_first = 1;            elseif (found_first == 1) && (found_second == 0)                daughter_link(i,2) = j;                found_second = 1;            else                daughter_link(i,3) = j; % if we never do this it goes to zero anyway            end        end    end    endendfunction  branching_level_result = find_branch_level(parent)% assigns to each branch a number that indicates how far it is from the% root, with the root being assigned a level of zeronumentries = length(parent);for i=1:numentries    level_counter = 0;    current = i;    found_root = 0;    while found_root == 0        level_counter = level_counter + 1;        if level_counter > numentries            break;  % this should be impossible        end        if parent(current) == 0 % this means we hit the root            branching_level_result(i) = level_counter;            found_root = 1;        else            current = parent(current); % traverse the parent links till get to the root        end    endendendfunction terminal_branches = find_terminal_branches(daughter_links)% examines a daughter link structure and flags all the terminal branches% teh output array takes the value 1 for entry i if i is a terminal branch,% i.e. one that has no daughtersnumentries = length(daughter_links); % length returns largest dimensionterminal_branches = zeros(numentries, 1);for i=1:numentries    if sum(daughter_links(i,:)) == 0        terminal_branches(i) = 1;  % no daughters means terminal branch    endendendfunction ancestor_results = find_ancestor_array(parent)% function that generates a binary array with 1 in entry% ancestor_array(i,j) if i is an ancestor of jnumentries = length(parent);is_ancestor =zeros(numentries);for i=1:numentries    for j=1:numentries                if parent(i) == j            is_ancestor(i,j) = 1; % means j is an ancestor of i        end            endendnum_levels = round(log2(numentries)) + 2;  % number of iterations to traverse balanced treefor k=1:num_levels    for i=1:numentries    for j=1:numentries                if is_ancestor(i,j) > 0   % j is ancestor of i            % in that case i should inherit all ancestors from j            is_ancestor(i,:) = is_ancestor(i,:) + is_ancestor(j,:);                    end            end    end    endancestor_results = is_ancestor;endfunction  [x_projected y_projected] = mollweide_projection(angle_theta, angle_phi)%  computes the x and y values for a point on the surface of a sphere using%  the Mollweide projectionlatitude = (pi/2.0) - angle_phi;  %convert from spherical coordinate phi to latitude% now find the auxilliary angle by Newton-Raphsonaux_angle = latitude;for k=1:200    new_aux_angle = aux_angle - (2*aux_angle + sin(2*aux_angle) - pi*sin(latitude))/(2 + 2*cos(2*aux_angle));    aux_angle = new_aux_angle;endx_projected = (2*sqrt(2)/pi)*angle_theta*cos(aux_angle);y_projected = sqrt(2)*sin(aux_angle);end